<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>编码修复测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .result {
            background: #f5f5f5;
            padding: 10px;
            border-radius: 3px;
            margin: 10px 0;
            white-space: pre-wrap;
            font-family: monospace;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
    </style>
</head>
<body>
    <h1>编码修复测试</h1>
    
    <div class="test-section">
        <h2>测试数据</h2>
        <p>这是一个包含乱码的测试数据：</p>
        <div class="result" id="originalData">eyJuYW1lIjoi5L+e5LmQ5LmQIiwiZGVzY3JpcHRpb24iOiJb6KeS6Imy5ZCNXTpcclxuICDkuK3mloflkI06IOS/nuS5kOS5kFxy</div>
        <button onclick="testEncoding()">测试编码修复</button>
    </div>
    
    <div class="test-section">
        <h2>修复结果</h2>
        <div class="result" id="result">点击按钮开始测试...</div>
    </div>
    
    <div class="test-section">
        <h2>控制台日志</h2>
        <div class="result" id="logs">等待测试...</div>
    </div>

    <script>
        // 编码修复函数
        function fixEncoding(decodedString) {
            console.log('开始修复编码问题...');
            console.log('原始字符串长度:', decodedString.length);
            console.log('原始字符串预览:', decodedString.substring(0, 100));
            
            // 检查是否包含乱码字符
            if (containsGarbledText(decodedString)) {
                console.log('检测到乱码，尝试修复...');
                return fixGarbledText(decodedString);
            }
            
            return decodedString;
        }
        
        function containsGarbledText(str) {
            const garbledPatterns = [
                /ä¿\x9E/,
                /ä¹\x90/,
                /è§\x92/,
                /è\x89²/,
                /å\x90\x8D/,
                /\x9E/g,
                /\x90/g,
                /\x92/g,
                /\x89/g
            ];
            
            return garbledPatterns.some(pattern => pattern.test(str));
        }
        
        function fixGarbledText(str) {
            console.log('尝试修复乱码文本...');
            
            // 将字符串转换为字节数组
            const bytes = new Uint8Array(str.length);
            for (let i = 0; i < str.length; i++) {
                bytes[i] = str.charCodeAt(i);
            }
            
            console.log('字节数组长度:', bytes.length);
            console.log('字节数组预览:', Array.from(bytes.slice(0, 20)));
            
            // 尝试不同的编码方式
            const encodings = ['utf-8', 'utf8', 'latin1', 'iso-8859-1'];
            
            for (const encoding of encodings) {
                try {
                    const decoder = new TextDecoder(encoding);
                    const fixedString = decoder.decode(bytes);
                    
                    // 检查修复后的字符串是否还包含乱码
                    if (!containsGarbledText(fixedString)) {
                        console.log(`使用 ${encoding} 编码修复成功`);
                        return fixedString;
                    }
                } catch (error) {
                    console.log(`${encoding} 编码修复失败:`, error);
                }
            }
            
            console.log('所有编码方式都失败，尝试手动修复...');
            
            // 手动修复常见的乱码模式
            let fixedString = str;
            
            // 修复常见的乱码字符
            const fixMap = {
                'ä¿': '保',
                'ä¹': '佑',
                'è§': '角',
                'è²': '色',
                'å': '名',
                'å¤': '外',
                'å·': '号',
                'å¸': '常',
                'å¨': '挂',
                'å´': '在',
                'å°´': '嘴',
                'è¾¹': '边',
                'ç': '的',
                'è¯': '话',
                'â': '"',
                '€': '"',
                '¼': ',',
                '½': '你',
                '¾': '少',
                '管': '管',
                'æ': '我',
                '¡': '！'
            };
            
            for (const [garbled, fixed] of Object.entries(fixMap)) {
                fixedString = fixedString.replace(new RegExp(garbled, 'g'), fixed);
            }
            
            console.log('手动修复完成');
            return fixedString;
        }
        
        function testEncoding() {
            const logs = [];
            const originalConsoleLog = console.log;
            console.log = function(...args) {
                logs.push(args.join(' '));
                originalConsoleLog.apply(console, args);
            };
            
            try {
                const testData = document.getElementById('originalData').textContent;
                logs.push('=== 开始编码修复测试 ===');
                
                // 解码 Base64
                const decodedData = atob(testData);
                logs.push('Base64 解码后数据:', decodedData);
                
                // 尝试修复编码
                const fixedData = fixEncoding(decodedData);
                logs.push('修复后数据:', fixedData);
                
                // 尝试解析 JSON
                const jsonData = JSON.parse(fixedData);
                logs.push('解析成功:', JSON.stringify(jsonData, null, 2));
                
                document.getElementById('result').textContent = JSON.stringify(jsonData, null, 2);
                
            } catch (error) {
                logs.push('测试失败:', error.message);
                document.getElementById('result').textContent = '测试失败: ' + error.message;
            }
            
            document.getElementById('logs').textContent = logs.join('\n');
            console.log = originalConsoleLog;
        }
    </script>
</body>
</html> 